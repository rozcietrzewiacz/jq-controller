apiVersion: v1
data:
  controller.sh: "#!/bin/bash\n#TODO ideas:\n# - run filterApplyLoop in subprocess,\n#   so that it can be killed/waitedfor by the exit trap\n# - split out json mode for extraargs, using something like\n#     value=$( < $name jq '@json' )\n#   to read it\n# - (?) construct the ownerReferences part within this script\n\n: ${WATCH_TARGET:=\"configmap\"} # Object being watched\n: ${WATCH_MASK:=\".data\"} # Only react to changes in that object path\n: ${EXTRA_ARGS_PATH:=\"\"}\n: ${TRANSFORM_DEF_FILE:=\"/in/filter.jq\"}\n: ${WATCH_EVENTS:='ADDED, MODIFIED'}\n\nmsg() { echo \"$@\"; }\ndbg() { [ \"$DEBUG\" ] && msg \">DEBUG> $@\"; }\nkj() {\n  kubectl $@ -o json \\\n    | jq --unbuffered -c --arg watch_events \"$WATCH_EVENTS\" \\\n      '\n        .type as $type\n        | select(\n            ( $watch_events | split(\", \") | index($type) ) != null\n          )\n        | .object\n      '\n}\n\nfilterApplyLoop() {\n  local inputUpdate lastValue result\n  dbg \"in filterApplyLoop\"\n  while read -r inputUpdate\n  do\n    dbg \"Read new json: \\\"$inputUpdate\\\"\"\n    [ \"${inputUpdate}\" == \"${lastValue}\" ] \\\n    || {\n      msg \"> Update detected\"\n      <<<${inputUpdate} jq -c \\\n        -f ${TRANSFORM_DEF_FILE} \\\n        $JQ_EXTRA_ARGS \\\n      | kubectl apply -f -\n      result=$?\n      lastValue=\"${inputUpdate}\"\n    }\n  done\n  msg \">> APPLY LOOP EXITED\"\n  if [ $result -gt 0 ]\n  then\n    msg \"Dumping dry-run output:\"\n    <<<${inputUpdate} jq -c \\\n      -f ${TRANSFORM_DEF_FILE} \\\n      $JQ_EXTRA_ARGS \n  done\n}\n\nmsg \">> JQ Controller startig...\"\nmsg \" > watching resource: $WATCH_TARGET\"\nmsg \" > watch json mask: $WATCH_MASK\"\nmsg \" > transform definition file: $TRANSFORM_DEF_FILE\"\n[ -r ${TRANSFORM_DEF_FILE} ] || {\n  msg \"ERROR: $TRANSFORM_DEF_FILE is not readable!\" | tee /dev/stderr\n  ls -l \"${TRANSFORM_DEF_FILE}\" 2>&1\n  exit 1\n}\nWATCH_LIST=${TRANSFORM_DEF_FILE}:x\nWATCH_LIST+=\" ${BASH_ARGV0}:ex\"\n[ \"${EXTRA_ARGS_PATH}\" != \"\" ] && {\n  echo .... obtaining args from ${EXTRA_ARGS_PATH} ....\n  cd ${EXTRA_ARGS_PATH}\n  for name in *\n  do\n    if [[ $name == *\".json\" ]]\n    then\n      value=$( < $name jq '@json' )\n      JQ_EXTRA_ARGS+=\" --argjson ${name%%\\.json} $value\"\n    else\n      value=$(< $name )\n      JQ_EXTRA_ARGS+=\" --arg $name $value\"\n    fi\n    WATCH_LIST+=\" ${EXTRA_ARGS_PATH}/${name}:x\"\n  done\n  cd - &>/dev/null\n  echo \"JQ_EXTRA_ARGS: $JQ_EXTRA_ARGS\"\n}\n\nhandleExit() {\n  msg \">> INTERRUPT caught. Killing own pod <<\"\n  set -x\n  #We need to force our parent to generate new pod,\n  # so that our children can be recreated\n  kubectl delete pod $HOSTNAME --wait=false --grace-period=2\n  #alternatively, if pod name is exposed through downwardAPI:\n  #kubectl delete po $(< ${EXTRA_ARGS_PATH}/name )\n  #exit\n}\n\n####################\ntrap handleExit EXIT QUIT KILL TERM\necho \"MY PID: $$\"\nset -x\ninotifyd /ctr/reloader.sh ${WATCH_LIST} &\ntrap -p\nset +x\nwhile true\ndo\n  kj get --watch --output-watch-events  ${WATCH_TARGET} | filterApplyLoop\ndone\n"
  reloader.sh: "#!/bin/bash\necho \">> reload called with args: $@\" &>> /home/shell/reloader.log\necho \">> Change detected in $2. Reloading...\" &>> /home/shell/reloader.log \nset -x &>> /home/shell/reloader.log\nkill 1 &>> /home/shell/reloader.log\n#If own pod is still alive, try to kill it from here:\n#kubectl delete pod $HOSTNAME\necho &>> /home/shell/reloader.log\n"
kind: ConfigMap
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","data":{"controller.sh":"#!/bin/bash\n#TODO ideas:\n# - run filterApplyLoop in subprocess,\n#   so that it can be killed/waitedfor by the exit trap\n# - split out json mode for extraargs, using something like\n#     value=$( \u003c $name jq '@json' )\n#   to read it\n# - (?) construct the ownerReferences part within this script\n\n: ${WATCH_TARGET:=\"configmap\"} # Object being watched\n: ${WATCH_MASK:=\".data\"} # Only react to changes in that object path\n: ${EXTRA_ARGS_PATH:=\"\"}\n: ${TRANSFORM_DEF_FILE:=\"/in/transform.jq\"}\n\nmsg() { echo \"$@\"; }\ndbg() { [ \"$DEBUG\" ] \u0026\u0026 msg \"\u003eDEBUG\u003e $@\"; }\nkj() { kubectl $@ -o json | jq --unbuffered -c \"$WATCH_MASK\"; }\nfilterApplyLoop() {\n  local inputUpdate lastValue\n  dbg \"in filterApplyLoop\"\n  while read -r inputUpdate\n  do\n    dbg \"Read new json: \\\"$inputUpdate\\\"\"\n    [ \"${inputUpdate}\" == \"${lastValue}\" ] \\\n    || {\n      msg \"\u003e Update detected\"\n      \u003c\u003c\u003c${inputUpdate} jq -c \\\n        -f ${TRANSFORM_DEF_FILE} \\\n        $JQ_EXTRA_ARGS \\\n      | kubectl apply -f -\n      lastValue=\"${inputUpdate}\"\n    }\n  done\n  msg \"\u003e\u003e APPLY LOOP EXITED\"\n}\n\nmsg \"\u003e\u003e JQ Controller startig...\"\nmsg \" \u003e watching resource: $WATCH_TARGET\"\nmsg \" \u003e watch json mask: $WATCH_MASK\"\nmsg \" \u003e transform definition file: $TRANSFORM_DEF_FILE\"\n[ -r ${TRANSFORM_DEF_FILE} ] || {\n  msg \"ERROR: $TRANSFORM_DEF_FILE is not readable!\" | tee /dev/stderr\n  ls -l \"${TRANSFORM_DEF_FILE}\" 2\u003e\u00261\n  exit 1\n}\nWATCH_LIST=${TRANSFORM_DEF_FILE}:x\nWATCH_LIST+=\" ${BASH_ARGV0}:ex\"\n[ \"${EXTRA_ARGS_PATH}\" != \"\" ] \u0026\u0026 {\n  echo .... obtaining args from ${EXTRA_ARGS_PATH} ....\n  cd ${EXTRA_ARGS_PATH}\n  for name in *\n  do\n    if [[ $name == *\".json\" ]]\n    then\n      value=$( \u003c $name jq '@json' )\n      JQ_EXTRA_ARGS+=\" --argjson ${name%%\\.json} $value\"\n    else\n      value=$(\u003c $name )\n      JQ_EXTRA_ARGS+=\" --arg $name $value\"\n    fi\n    WATCH_LIST+=\" ${EXTRA_ARGS_PATH}/${name}:x\"\n  done\n  cd - \u0026\u003e/dev/null\n  echo \"JQ_EXTRA_ARGS: $JQ_EXTRA_ARGS\"\n}\nhandleExit() {\n  msg \"\u003e\u003e INTERRUPT caught. Killing own pod \u003c\u003c\"\n  set -x\n  #We need to force our parent to generate new pod,\n  # so that our children can be recreated\n  kubectl delete pod $HOSTNAME\n  #alternatively, if pod name is exposed through downwardAPI:\n  #kubectl delete po $(\u003c ${EXTRA_ARGS_PATH}/name )\n  #exit\n}\n####################\ntrap handleExit EXIT\necho \"MY PID: $$\"\nset -x\ninotifyd /c/reloader.sh ${WATCH_LIST} \u0026\ntrap -p\nset +x\nwhile true\ndo\n  kj get --watch ${WATCH_TARGET} | filterApplyLoop\ndone\n","reloader.sh":"#!/bin/bash\necho \"\u003e\u003e reload called with args: $@\" \u0026\u003e\u003e /var/log/reloader.log\necho \"\u003e\u003e Change detected in $2. Reloading...\" \u0026\u003e\u003e /var/log/reloader.log \nset -x \u0026\u003e\u003e /var/log/reloader.log\nkill 1 \u0026\u003e\u003e /var/log/reloader.log\n#If own pod is still alive, try to kill it from here:\n#kubectl delete pod $HOSTNAME\necho \u0026\u003e\u003e /var/log/reloader.log\n"},"kind":"ConfigMap","metadata":{"annotations":{},"name":"jq-controller","namespace":"jq-ctr"}}
  creationTimestamp: "2023-02-19T02:54:16Z"
  name: jq-controller
  namespace: jq-ctr
  resourceVersion: "22324155"
  uid: 61ab1f37-e4d8-44b5-9a43-14a15abf9531
